/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 * 
 * This file represents the Relying Party (RPC Client).
 * Responsibilities:
 * 1. Sends requests to the server:
 *    - requestAuthZ: Initiates an AuthZ request to authorize a user.
 *    - approveAuthZ: Asks the end-user (simulated by the server) to approve the request.
 *    - generateAccessToken: Requests an Access Token from the server.
 *    - refreshAccessToken: Requests a new Access Token using a Refresh Token.
 *    - executeDelegatedAction: Executes operations on resources managed by the server.
 * 
 * 2. Manages client-server communication:
 *    - Initializes an RPC client connection.
 *    - Handles responses from the server, including errors.
 * 
 * 3. Reads operations from a local CSV file and processes them sequentially (to be implemented).
 */


#include "rpc_config.h"
#include "token.h"

#define LINE_SIZE 256

// structure used to keep evidence of users and their tokens
typedef struct {
  char* user_id;
  char* authz_token;
  char* access_token;
  char* refresh_token;
  int auto_refresh;
  int ttl;
} Users;


/**
 * This method manages the main logic for the client, respecting the OAuth architecture.
 * The client reads commands from 'client.in' file and processes them one by one.
 */
void
oauth_prog_1(char *host, const char *input_file) {
    CLIENT *clnt;
    AuthZResponse *result_1, *result_2;
    AccessTokenResponse *result_3, *result_4;
    DelegatedActionResponse *result_5;

    Users users[LINE_SIZE];
    int users_index = 0;
 
    clnt = clnt_create(host, OAUTH_PROG, OAUTH_VERS, "udp");
    if (clnt == NULL) {
      clnt_pcreateerror(host);
      exit(1);
    }

    FILE *file = fopen(input_file, "r");
    if (file == NULL) {
      clnt_perror(clnt, "Couldnt open client input file");
      clnt_destroy(clnt);
      exit(1);
    }

    FILE *client_output = fopen("client.out", "w");
    if (client_output == NULL) {
      clnt_perror(clnt, "Couldnt open client output file");
      clnt_destroy(clnt);
      exit(1);
    }

    char line[LINE_SIZE];
    while (fgets(line, LINE_SIZE, file)) {
        line[strcspn(line, "\n")] = '\0';

        char user_id[LINE_SIZE], action[LINE_SIZE], resource[LINE_SIZE];
        int auto_refresh = 0;

        // parse a CSV line and extract each component of the command
        int fields = sscanf(line, "%[^,],%[^,],%[^,\n]", user_id, action, resource);

        if (fields < 2) {
            clnt_perror(clnt, "Invalid client input line\n");
            continue;
        }

        if (strcmp(action, "REQUEST") == 0) {
            // process 'REQUEST' command
            auto_refresh = atoi(resource);
            
            // create an authorization request to recieve an authz token
            AuthZRequest auth_request;
            auth_request.user_id = strdup(user_id);

            result_1 = requestauthz_1(&auth_request, clnt);
            if (result_1 == NULL) {
                clnt_perror(clnt, "REQUEST AUTHZ failed");
                free(auth_request.user_id);
                continue;
            }

            if (result_1->error_code != 0) {
              fprintf(client_output, "%s\n", result_1->message);
              free(auth_request.user_id);
              continue;
            }

            // approve authorization by the end-user for the token recieved
            AuthZResponse approve_request;
            approve_request.user_id = strdup(result_1->user_id);
            approve_request.token = strdup(result_1->token);
            approve_request.error_code = 0;
            approve_request.message = "";
            result_2 = approveauthz_1(&approve_request, clnt);

            if (result_2 == NULL) {
                clnt_perror(clnt, "APPROVE AUTHZ failed");
                free(approve_request.user_id);
                free(approve_request.token);
                continue;
            }

            if (result_2->error_code != 0) {
              fprintf(client_output, "%s\n", result_2->message);
              free(approve_request.user_id);
              free(approve_request.token);
              continue;
            }

            // create an acces request to recieve an access token based on the approval of the end-user
            AccessTokenRequest token_request;
            token_request.user_id = strdup(user_id);
            token_request.authz_token = strdup(result_1->token);
            token_request.auto_refresh = auto_refresh;
            token_request.refresh_token = "";

            result_3 = generateaccesstoken_1(&token_request, clnt);

            if (result_3 == NULL) {
              clnt_perror(clnt, "GENERATE ACCESS failed");
              free(token_request.user_id);
              free(token_request.authz_token);
              continue;
            } 
            
            if (result_3 -> error_code != 0) {
              fprintf(client_output, "%s\n", result_3->message);
              free(token_request.user_id);
              free(token_request.authz_token);
              continue;
            }

            if (!auto_refresh)
              fprintf(client_output, "%s -> %s\n", result_2->token, result_3->access_token);
            else
              fprintf(client_output, "%s -> %s,%s\n", result_2->token, result_3->access_token, result_3->refresh_token);

            int found = 0;
            for (int i = 0; i < users_index; i ++) {
              if (!strcmp(users[i].user_id , user_id)) {
                // refresh info from client's data-structure 'users' if user already exists
                users[i].user_id = strdup(user_id);
                users[i].authz_token = strdup(result_2->token);
                users[i].access_token = strdup(result_3->access_token);
                users[i].refresh_token = strdup(result_3->refresh_token);
                users[i].auto_refresh = auto_refresh;
                users[i].ttl = result_3->access_token_ttl;
                found = 1;
                break;
              }
            }

            if (!found) {
              // create new entry in client's data-structure if user doesnt exist
              users[users_index].user_id = strdup(user_id);
              users[users_index].authz_token = strdup(result_2->token);
              users[users_index].access_token = strdup(result_3->access_token);
              users[users_index].refresh_token = strdup(result_3->refresh_token);
              users[users_index].auto_refresh = auto_refresh;
              users[users_index].ttl = result_3->access_token_ttl;
              users_index ++;
            }

            free(auth_request.user_id);
            free(approve_request.user_id);
            free(approve_request.token);
            free(token_request.user_id);
            free(token_request.authz_token);

        } else {
            // process a 'RIMDX' command
            int user_index = -1;
  
            // check if user exists in client's data-structure
            for (int i = 0; i < users_index; i ++) {
              if (!strcmp(user_id, users[i].user_id)) {
                user_index = i;

                // check if user has auto-refresh enabled and needs a refresh to execute current command
                if (users[i].ttl == 0  && users[i].auto_refresh) {
                  AccessTokenRequest refresh_request;
                  refresh_request.user_id = strdup(users[i].user_id);
                  refresh_request.authz_token = strdup(users[i].authz_token);
                  refresh_request.refresh_token = strdup(users[i].refresh_token);
                  refresh_request.auto_refresh = users[i].auto_refresh;

                  result_4 = refreshaccesstoken_1(&refresh_request, clnt);
                  if (result_4 == NULL) {
                    clnt_perror(clnt, "Refresh failed");
                    free(refresh_request.user_id);
                    free(refresh_request.authz_token);
                    free(refresh_request.refresh_token);
                    continue;
                  }

                  if (result_4->error_code != 0) {
                    fprintf(client_output, "%s\n", result_4->message);
                    free(refresh_request.user_id);
                    free(refresh_request.authz_token);
                    free(refresh_request.refresh_token);
                    continue;
                  }

                  users[i].access_token = strdup(result_4->access_token);
                  users[i].refresh_token = strdup(result_4->refresh_token);
                  users[i].ttl = result_4->access_token_ttl;

                  free(refresh_request.user_id);
                  free(refresh_request.authz_token);
                  free(refresh_request.refresh_token);

                } else {
                  break;
                }
              }
            }

            if (user_index == -1) {
              // user doesnt exist in the data-structure yet
              users[users_index].user_id = strdup(user_id);
              users[users_index].authz_token = "";
              users[users_index].access_token = "";
              users[users_index].refresh_token = "";
              users[users_index].auto_refresh = 0;
              users[users_index].ttl = 0;
              user_index = users_index;
              users_index ++;
            }

            DelegatedAction action_request;
            action_request.user_id = strdup(user_id);
            action_request.operation = strdup(action);
            action_request.resource = strdup(resource);
            action_request.access_token = strdup(users[user_index].access_token);

            result_5 = executedelegatedaction_1(&action_request, clnt);
            if (result_5 == NULL) {
                clnt_perror(clnt, "Operation failed");
            } 

            fprintf(client_output, "%s\n", result_5->message);
            users[user_index].ttl --;

            free(action_request.user_id);
            free(action_request.operation);
            free(action_request.resource);
            free(action_request.access_token);
        }
    }

    fclose(file);
    fclose(client_output);
    clnt_destroy(clnt);
}


int
main (int argc, char *argv[])
{
	char *host;
  char *client_input;

	if (argc != 3) {
      fprintf(stderr, "Usage: %s <server_address> <input_file>\n", argv[0]);
      exit(1);
  }

	host = argv[1];
  client_input = argv[2];

	oauth_prog_1 (host, client_input);
  exit (0);
}

